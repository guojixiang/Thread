##同步方法知识点
1、方法内的变量为线程安全。

2、实例变量非线程安全：
    
    情况说明：
        1、用线程访问的对象中如果有多个实例变量，则运行的结果有可能出现交叉的情况。
        2、如果对象仅有1个实例变量，则有可能出现覆盖的情况；
结论：两个线程访问同一个对象的同步方法时一定是线程安全的。

3、验证：多个对象多个锁：
   
   1. 创建一个类的多个实例，不同线程持有不同实例，运行效果呈现异步；
   
   2. synchronized 取得的锁都是对象锁，而不是把一段代码或方法（函数）作为锁。

4、调用用关键字synchronized声明的方法一定是排队运行的。只有共享资源的读写访问才需要同步化，如果不是共享资源，那么根本没有同步的必要；
      
    1、A线程先持有object对象的Lock锁，B线程可以以异步的方式调用object对象中的非synchronized的方法。
    2、A线程先持有object对象的lock锁，B线程如果在这时调用object对象中的synchronized类型的方法则需要等待，也就是同步。 

5、脏读一定会出现在操作实例变量的情况下，这就是不同线程“争抢”实例变量的结果。

6、线程执行的代码出现异常时，其所持有的锁会自动释放。

7、同步不具有继承性

8、可重入锁。关键字synchronized拥有锁重入的功能，即：当一个线程得到一个对象锁后，再次请求此对象锁可以再次得到该对象的锁的。
这也证明了synchronized方法/块的内部调用本类的其他synchronized方法/块时，是永远可以得到锁的。

* 可重入锁：
    1. 自己可以再次获取自己的内部锁。
    2. 可重入锁也支持在父子类继承的环境中。

当存在父子类继承关系时，子类是完全可以通过“可重入锁”调用父类的同步方法的。