摘要：自定义线程类中的实例变量针对其它线程可以有共享和不共享之分，这在多个线程之间进行交互时是很重要的一个技术点。

数据不共享：即每个对象操作自己的实例变量，互不干扰。
数据共享：多个线程可以访问同一个变量。（容易产生“非线程安全问题”）

非线程安全：多个线程对同一对象中的同一实例进行操作时，会出现值被更改，值不同步的现象，进而影响程序的执行流程。

如何解决“非线程安全问题”呢？

思路：当多个线程访问同一变量时，采用顺序排队的机制，保证数据同步（实现方式：synchronized关键字）

synchronized:同步锁（加锁的这段代码被称为：“互斥区”或“临界区”）

当一个线程要执行同步方法里的代码时，线程会首先尝试拿到同步锁。
若拿到，则执行synchronized里边的代码。
若未拿到，就会不断的尝试拿到该锁，直到拿到为止。（是多个线程同时抢占该锁）

特别提醒：留意i--与System.out.println()的异常。
    public void run() {
        System.out.println("i="+(i--)+"threadName="+Thread.currentThread().getName());
}

虽然println()方法内部是同步的，但i--操作确实在进入println()之前发生的，存在“非线程安全问题”