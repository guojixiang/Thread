##Thread类的常用方法

   1、currentThread()
   
   返回代码段正在被哪个线程调用的信息。
     
   返回对象：Thread.
   
   用法：1、Thread.currentThread(); 2、this.currentThread()
     
   Thread和this的调用区别？
   
   1. Thread.currentThread()：返回调用该代码片段或者方法的线程对象
   2. this.currentThread()：返回该代码片段所在线程的对象信息。
    
   2、isAlive()
   
   判断当前线程是否处于活动状态。
     
   活动状态：线程已经启动且尚未终止。线程处于正在运行或准备开始运行的状态，就认为线程是“存活”的。
     
   注意：
   在使用isAlive()方法时，如果将线程对象以构造参数的方式传递给Thread对象进行start()启动时，运行的结果和该线程直接启动是有差异的。
   造成这样差异的原因是：Thread.currentThread()和this的差异。
                   
   3、sleep()
    
   在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。这个“正在执行的线程”是指this.currentThread()返回的线程。
   
   4、getId()
   
   取得线程的唯一标识。
   
   5、停止线程，在java中有3种方法可以终止正在运行的线程：
   
   1. 使用退出标志，使线程正常退出，也就是当run方法完成后终止线程。
   2. 使用stop方法强行终止线程。不推荐使用该方法，stop、suspend和resume一样，都是过期作废的方法，使用他们可能产生不可预料的后果。
   3. 使用interrupt方法中断线程。
           
    interrupt()：
        该方法仅仅是在当前线程打了一个停止的标记，并不是真的停止线程。
        判断线程是否是停止状态？
        1、this.interrupted()：执行后具有将状态标志清除为false的功能。
        测试当前线程是否已经中断（当前线程指：运行该方法的线程）。线程的中断状态由该方法清除，如果连续两次调用该方法，则第二次将返回false(在第一次调用已经清除了中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外)。
        2、this.isInterrupted():测试线程是否已经中断。执行后不清除状态标志。
        如何停止线程执行呢？
        1、通过判断中断标志，抛出InterruptedException异常进行停止。
        2、在沉睡中停止：在sleep状态下停止某一个线程，会进入catch语句，并且清楚停止状态值，使之变成false。
        3、暴力停止：使用stop();容易出现数据不同步，不一致的问题。
        4、将interrupt()和return结合使用停止。（建议使用抛出异常的方式停止线程，在catch块中可以对异常信息进行相关的处理，使异常流能更好更方便的控制程序的运行流程，不至于代码中出现很多个return;,造成污染）
   
   
   6、yield()
   
   放弃当前的cpu资源，将它让给其他的任务去占用CPU执行时间。放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。
      
   7、线程的优先级
    
   线程可以划分优先级，优先级较高的线程得到的cpu资源较多。（cpu优先执行优先级较高的线程对象中的任务）
   
   setPriproity():java中线程优先级分为1~10,若大于10或小于1，则JDK抛出异常：IllegalArgumentException();
   
   java中使用3个常量来预置定义优先级的值：
   
   public final static int MIN_PRIORITY = 1;
   public final static int NORM_PRIORITY = 5;
   
   public final static int MAX_PRIORITY = 10;
      
      优先级的三个特性：
      1、继承特性：若A线程启动B线程，则B线程的优先级与A是一样的。
      2、规则性：
            高优先级的线程总是大部分先执行完，但不代表高优先级的线程全部先执行完。（当优先级的差距很大时，谁先执行完和代码的调用顺序无关）。最后一句话：cpu尽量将执行资源让给优先级比较高的线程。
      3、随机性
            优先级高的程序不一定每一次都先执行完。
      

  8、守护线程
            
   java线程中有两种线程：用户线程，守护线程；
   守护线程：是一种特殊的线程，当线程中不再存在非守护线程时，则守护线程自动销毁。（典型举例：垃圾回收线程）
   设置线程为守护线程：setDaemon(true);